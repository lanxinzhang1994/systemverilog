# 1 Data type   

不严格的讲，system verilog 可以简单的看作是verilog的扩充，因此在此不再介绍verilog与system verilog重复的数据类型。

## 1.1 双状态数据类型    

为了能够更好的描述硬件行为，verilog中的数据类型为四状态数据类型，即数据包含1，0，x，z四个状态。然而有时往往并不需要变量具有四个状态，尤其是在高级建模的时候。在变量仅需要高低两个状态的应用场景下，四状态变量必然会造成一定的存储空间的浪费。

system verilog在verilog的基础上引入了两状态变量，常用的两状态变量包括：

bit，双状态，区别于reg [0:0]，wire[0:0] ，logic[0:0]

int，32位，有符号数，区别于integer

byte，8位，有符号数

shortint，16位，有符号数

longint，64位，有符号数      



## 1.2 logic 类型     

verilog中，寄存器类型reg和线网类型wire在使用时是有区分的，在混用时会造成错误。system verilog引入了新的logic类型，既可以在寄存器类型中使用，也可以在线网中使用。因此一般来说logic的使用场景包括reg和wire的使用场景。

**需要注意的是，logic不能用在有多个信号驱动的情况下，比如设计双向端口，这是就要老老实实的使用wire和reg。**        



## 1.3 数组      

### 1.3.1 定宽数组      

数组的使用无非就是如何声明数组和如何引用数组的元素，具体使用方法如下：

```verilog
int [7:0]    a ;   // 数组声明法1： 类型 [维数1][维数2][维数3]...   数组名;
int [2][3]   b ;   // 数组声明法2

b = '{'{1,2,3},{2,3,4}};   //数组初始化，记得要加‘

foreach(a[i])begin         //遍历数组
    a[i] =  0 ;            //数组元素引用法
end

foreach(b[i,j])begin       //多维数组遍历不能写做b[i][j] 
    b[i,j] = 0 ; 
end
```
**需要注意的是，初始化一个数组中的元素时，需要加符号`'`**。

### 1.3.2 动态数组     

较之与verilog必须在声明数组时声明数组的长度，system verilog允许在真正使用数组的时候定义数组长度，这就是**动态数组**。动态数组增加了程序的灵活性，同时在必要的时候节约了内存。

动态数组的声明：

```verilog
int a[];
```

在使用之前要声明数组长度，使用方法new[n]。

```verilog
int length = 8;

a = new[length];      //声明数组的长度，new使用的是方括号，要与class的new()区分

foreach(a[i])begin    
	a[i] = i ;
end

a = new[length];     //重新声明了数组的长度，此时原来a中的数据会失效，new的本质为分配内存空间 
a.delete();          //删除数组元素(释放内存空间)
```

**new[]的本质是分配一段新的内存空间**，如果之前分配的空间临时不足，想要重新多分配一段空间并保留原来数组内的数据，可以如下操作：

```verilog
int a[];
a = new[3];
a = '{0,1,2};

a = new[8](a);  

for(int i=3; i<8; i++)begin
	a[i] = i ;
end

//此时a = [0,1,2,3,4,5,6,7] ;
```

需要注意的是，动态数组分配内存空间的`new[]`,所使用的是中括号，要与声明对象的`new()`有所区别。



### 1.3.3 关联数组     

关联数组可以理解为一个可以使用不连续索引的数组。之所以有这样的一种数据类型，Chris Spear在《system verilog for verification》中给出了一种解释：**如果我们建模一个具有很大取址范围的处理器，比如1G，但是实际上我们并不会使用到全部的空间，仅仅使用其中不连续的某几小段，难道我们要为了这几小段存储空间向内存申请1G的空间吗？**   

关联数组的声明和使用：

```verilog
int a [int] ;  //[]中的int表示索引数据的数据类型

for(int i=0;i<16;i++)begin
    a[i*2] = i ; 
end
```

如果索引的数据类型不确定，可以使用* 来替代，如 int a[*]。但是这不是一种很好的设计风格。    



### 1.3.4 合并数组     

合并数组的各个元素可以作为一个整体进行变形。合并数组的声明与使用如下：

```verilog
logic [7:0][31:0]  a ;
logic [191:0]      b ;

a[1:0] = 64'hffff_ffff_ffff_ffff ;
a[5:2] = 128'd0 ;
b = a[5:0] ;
```

合并数组可与与定长数组混合使用 ，各个索引的对应关系比较容易混乱，总体来说是先索引定长数组的维数，在索引合并数组的维数。

```verilog
logic [7:0][31:0]  a [3:0][7:0] ; 

a[0][1][2][3] = 1'b1 ;  
```



## 1.4 队列       

队列是system verilog相对于verilog新加的一种数据类型，据称队列的操作较之与数组会快很多。  

队列的声明与操作如下：

```verilog
int a[$];   //使用$声明一个队列    
a = {1,2,3};  //队列的初始化较之与数组不需要加’   

//(1)insert(位置,元素)
a.insert(1,10);    // a = {1,10,2,3} ;

b[$] = {5,6};
a.insert(0,b);     // 可以insert一个队列   a = {5,6,1,10,2,3} ;   

//(2)delete(位置)
a.delete(1);      //a = {5,1,10,2,3};     

//push_front(元素) push_back(元素)
a.push_front(7);  //a={7,5,1,10,2,3};
a.push_back(8);   //a={7,5,1,10,2,3,8};

//pop_front() pop_back()
a.push_front();  //a={5,1,10,2,3,8};
a.push_back();   //a={5,1,10,2,3};  

//delete()
a.delete();       //删除整个队列   
```









